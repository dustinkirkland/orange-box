#!/bin/bash -xe
# Utility script to:
# - Upload an image to glance, cirros by default.
#   Since our Jenkins host is cut off from the outside
#   world, images are hard-coded and expected to exist in
#   following locations locally:
#
#     $HOME/cirros-0.3.0-x86_64-disk.img
#     $HOME/quantal-server-cloudimg-amd64-disk1.img
#
# - Configure networks in Nova's database.  Also hard-coded here
#   to configure:
#     - private instance network 192.168.21.0/24,
#        multi_host, bridge=br100, bridge_interface=eth1
#     - default floating ip pool 192.168.20.224/27
#     - secondary floating ip pool 192.168.20.223/27
#
# This script expects:
#   - Environment contains any variables needed by glance's client tools
#     (use inspect_environment.sh to generate envrc containing these)
#   - Passwordless ssh access to nova-cloud-controller, and passwordless
#     sudo access for the ubuntu user (to call nova-manage)


function setup_nova_network() {
  # Conditionally create nova's instance network and 2 floating ip pools
  # this takes place on the cloud-controller using nova-manage
  log "Logging into $NOVA_HOST and creating network via nova-manage"
  ssh ubuntu@"$NOVA_HOST" "[[ -e ~/network-created ]] || \
                    (sudo nova-manage network create private $NOVA_NET_PRIVATE_NET_CIDR \
                     1 256 --bridge=br100 --bridge_interface=eth1 --multi_host=T \
                     && touch ~/network-created)" ||
                   error_out "Could not create network."

  log "Logging into $NOVA_HOST and creating default floating IP pool"
  ssh ubuntu@"$NOVA_HOST" "[[ -e ~/floating-pool1-created ]] || \
                   (sudo nova-manage floating create $NOVA_NET_FLOATING_POOL_RANGE \
                    && touch ~/floating-pool1-created)" ||
                   error_out "Could not create default floating pool."

  log "Logging into $NOVA_HOST and creating secondary floating IP pool"
  ssh ubuntu@"$NOVA_HOST" "[[ -e ~/floating-pool2-created ]] || \
                   (sudo nova-manage floating create --ip_range=$NOVA_NET_FLOATING_POOL_RANGE_2 \
                     --pool=test_range && touch ~/floating-pool2-created)" ||
                   error_out "ERROR: Could not create secondary floatig pool."
}

function setup_quantum_network() {
  # SSHes to nova-c-c and uses the charm's quantum utility script with
  # creds generated by inspect_environment.sh.
  ssh ubuntu@"$NOVA_HOST" "\
                  OS_USERNAME=$OS_USERNAME OS_PASSWORD=$OS_PASSWORD \
                  OS_TENANT_NAME=$OS_TENANT_NAME  OS_AUTH_URL=$OS_AUTH_URL  \
                  OS_REGION_NAME=RegionOne \
                  quantum-ext-net -g $QUANTUM_EXT_NET_GW \
                  -c $QUANTUM_EXT_NET_CIDR \
                  -f $QUANTUM_FLOAT_RANGE \
                  -t services \
                  $QUANTUM_EXT_NET_NAME"
  ssh ubuntu@"$NOVA_HOST" "\
                OS_USERNAME=$OS_USERNAME OS_PASSWORD=$OS_PASSWORD \
                OS_TENANT_NAME=$OS_TENANT_NAME OS_AUTH_URL=$OS_AUTH_URL  \
                OS_REGION_NAME=RegionOne \
                quantum-tenant-net -t admin -r provider-router \
                $QUANTUM_FIXED_NET_NAME $QUANTUM_FIXED_NET_CIDR"

  # save the IDs of new network to envrc for later testing.
  ext_net_id=$(neutron net-list | grep "$QUANTUM_EXT_NET_NAME " | \
               awk '{ print $2 }')
  fixed_net_id=$(neutron net-list | grep "$QUANTUM_FIXED_NET_NAME " | \
               awk '{ print $2 }')
  ext_net_router=$(neutron router-list | grep "$ext_net_id" | \
               grep provider-router | awk '{ print $2 }')
  [[ -e envrc ]] &&
    echo "export QUANTUM_EXT_NET_ID=$ext_net_id" >>envrc &&
    echo "export QUANTUM_FIXED_NET_ID=$fixed_net_id" >>envrc &&
    echo "export QUANTUM_EXT_NET_ROUTER_ID=$ext_net_router" >>envrc
}

function setup_network() {
  if (echo $ENABLED_SERVICES | grep -q quantum) ||
     (echo $ENABLED_SERVICES | grep -q neutron) ; then
    setup_quantum_network
  else
    setup_nova_network
  fi
}


function ubuntu_image() {
  # certain compute backends require certain image formats
  case "$COMPUTE_BACKEND" in
    "vmware") echo $VMWARE_IMAGE ;;
    "lxc") echo $LXC_IMAGE ;;
    *) echo $DEFAULT_IMAGE ;;
  esac
}

function glance_args() {
  # certain compute backends require images be published with special
  # properties
  # NOTE: assumes vmware images are sparse. needs to be adjusted
  #       publishing preallocated or thin images
  case "$COMPUTE_BACKEND" in
    "vmware") echo "--disk-format=vmdk --container-format=bare " \
                   "--is-public=true --property vmware-adaptertype=ide " \
                   "--property vmware-ostype=ubuntuGuest " \
                   "--property vmware_disktype=sparse" ;;
    "lxc") echo "--container-format=bare --disk-format=raw --property hypervisor_type=lxc" \
                "--is-public true" ;;
    *) echo "--is-public=true --container-format=ami --disk-format=ami" ;;
  esac
}

function publish_image() {
  # Publish a cloud img directly into glance using glance client
  case "$1" in
    "ubuntu") IMG="$(ubuntu_image)" ;;
    "cirros"|*) IMG="$IMG_DIR/cirros-0.3.0-x86_64-disk.img" ;;
  esac
  [[ ! -e "$IMG" ]] && error_out "Could not find IMG @ $IMG"
  log "Using IMG @ $IMG."

  # Clear out any existing images.
  for i in $(glance image-list | grep active | awk '{ print $2 }') ; do
    log "Deleting existing image from glance with id $i"
    glance image-delete $i
  done

  IMG_NAME=$(echo ${IMG##*/} | sed -e 's/\.img//g')
  args="$(glance_args)"
  RESP=$(glance image-create --name="$IMG_NAME-ami" $args < $IMG)
  IMG_UUID=$(echo "$RESP" | grep " id " | awk '{ print $4 }')
  log "Published AMI for $IMG_NAME with ID $IMG_UUID"
  log "Cleaning up $IMG_NAME..."
  rm -rf $IMG_NAME*

  # Find the correpsonding EC2 AMI ID that was assigned the the Glance image.
  EC2_IMG_UUID=$(euca-describe-images | grep "$IMG_NAME-ami" | awk '{ print $2 }'  | head -n1)

  # if this is being run as part of jenkins job, its likely there is an envrc
  # in the pwd that we care to update with the name of the image we just published.
  [[ -e envrc ]] && \
    echo "export IMAGE_NAME=$IMG_NAME-ami" >>envrc && \
    echo "export IMAGE_UUID=$IMG_UUID" >>envrc
    echo "export EC2_IMG_UUID=$EC2_IMG_UUID" >>envrc
}
